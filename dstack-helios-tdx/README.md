# P2P Dstack Network of Helios Nodes

## TEE and light clients? 

Read the writeup [here](#).

## Replication

All communications are carried through the `/overlay` library, a stripped down version of the networking layer we're working on internally. The goal for our nodes is to replicate to be able to sign messages under the shared dstack public key. This public key emerges as a result of local choices of the TEE operator when joining the network rather than inferred by a bootstrap contract. 

> NB: we're not necessarily advocating for dstack nodes to infer the cluster they want to join based on operator choices. This is an experiment.

When a node is spinned up without specifying peers it assumes it's being bootstrapped and creates it own view of the dstack newtork. Other peers can now be spinned up and join the bootstrapped node.

When they request to join the bootsrapped node a P2P connection over QUIC is established between the two peers as follows:

```
Peer wants to join bootstrap B_0 -> Peer establishes connection with B_0.
Both nodes send their attestation paired with their local pubkey -> mutual authentication happens
|-> mutual authentication establishes a secure encrypted communication channel between the two nodes. 
|-> during mutual authentication the two nodes establish a session key used as base for the nonce. The session key is simply the highest value between two values randomly generated by both peers (NB: both peers are already attested at this point).

The peers now communicate over the encrypted p2p channel.
```

Among other things, this approach ensures that applications where various TEEs work together to achieve a unified application state on the leader TEE don't necessarily share the same level of authentication because the communication channels are p2p and not shared across the dstack nodes. By caching the shared cipher this doesn't add overhead. 

> NB: there's situations where the overlay will want to share with multiple TEEs of the same authorization group. In such situations sharing a secret across authorization groups can be beneficial for networking workload on the encryption; on the full implementation we reserve a message type for this.

> NB: replication is currently not safe, see the below paragraph.

# A meta-dstack note

As you'll learn when applying what is instructed in the `meta-dstack-patch`, this very first example relies on the app logic being within the TEE and there is no virtualization or abstraction for configuration environment variables yet. The reason is because we don't expect to be maintaining the base TEE dstack image ourselves. 

We might change this very soon when we switch to having an alchemy API key at which point we can add logic to handle such variables even without virtualizing (think simple API to initialize the VM). Once we add this, we can start adding measurements checks even if it's not the optimal setup (on system vs reserved measurement) thus making the replication actuall safe. 

## Modularization

This implementation is currently reliant on the `mock` crate to get the quote. If we were to virtualize the application we would simply have the mock function interact with the hopefully modular (i.e can choose which features to have, with the minimal being getting quotes) guest backend instead of interacting with tsm directly. 

# Build and use

See [meta-dstack-patch](./meta-dstack-patch/README.md).
